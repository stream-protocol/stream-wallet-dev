"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
require("mocha");
const decimal_1 = require("./decimal");
const int_1 = require("./int");
describe("Test decimals", () => {
    it("dec should be parsed from str properly", () => {
        let dec = new decimal_1.Dec("10.009");
        assert_1.default.strictEqual(dec.toString(), "10.009000000000000000");
        assert_1.default.strictEqual(dec.toString(2), "10.00");
        dec = new decimal_1.Dec("-123.45678900");
        assert_1.default.strictEqual(dec.toString(), "-123.456789000000000000");
        assert_1.default.strictEqual(dec.toString(3), "-123.456");
        dec = new decimal_1.Dec("10");
        assert_1.default.strictEqual(dec.toString(), "10.000000000000000000");
        assert_1.default.throws(() => {
            new decimal_1.Dec("");
        });
        assert_1.default.throws(() => {
            new decimal_1.Dec("0.-75");
        });
        assert_1.default.throws(() => {
            new decimal_1.Dec("0.489234893284938249348923849283408");
        });
        assert_1.default.throws(() => {
            new decimal_1.Dec("foobar");
        });
        assert_1.default.throws(() => {
            new decimal_1.Dec("0.foobar");
        });
        assert_1.default.throws(() => {
            new decimal_1.Dec("foobar.0");
        });
    });
    it("dec should be caculated properly", () => {
        const tests = [
            {
                d1: new decimal_1.Dec(0),
                d2: new decimal_1.Dec(0),
                expMul: new decimal_1.Dec(0),
                expMulTruncate: new decimal_1.Dec(0),
                expQuo: new decimal_1.Dec(0),
                expQuoRoundUp: new decimal_1.Dec(0),
                expQuoTruncate: new decimal_1.Dec(0),
                expAdd: new decimal_1.Dec(0),
                expSub: new decimal_1.Dec(0),
            },
            {
                d1: new decimal_1.Dec(0),
                d2: new decimal_1.Dec(1),
                expMul: new decimal_1.Dec(0),
                expMulTruncate: new decimal_1.Dec(0),
                expQuo: new decimal_1.Dec(0),
                expQuoRoundUp: new decimal_1.Dec(0),
                expQuoTruncate: new decimal_1.Dec(0),
                expAdd: new decimal_1.Dec(1),
                expSub: new decimal_1.Dec(-1),
            },
            {
                d1: new decimal_1.Dec(-1),
                d2: new decimal_1.Dec(0),
                expMul: new decimal_1.Dec(0),
                expMulTruncate: new decimal_1.Dec(0),
                expQuo: new decimal_1.Dec(0),
                expQuoRoundUp: new decimal_1.Dec(0),
                expQuoTruncate: new decimal_1.Dec(0),
                expAdd: new decimal_1.Dec(-1),
                expSub: new decimal_1.Dec(-1),
            },
            {
                d1: new decimal_1.Dec(-1),
                d2: new decimal_1.Dec(1),
                expMul: new decimal_1.Dec(-1),
                expMulTruncate: new decimal_1.Dec(-1),
                expQuo: new decimal_1.Dec(-1),
                expQuoRoundUp: new decimal_1.Dec(-1),
                expQuoTruncate: new decimal_1.Dec(-1),
                expAdd: new decimal_1.Dec(0),
                expSub: new decimal_1.Dec(-2),
            },
            {
                d1: new decimal_1.Dec(3),
                d2: new decimal_1.Dec(7),
                expMul: new decimal_1.Dec(21),
                expMulTruncate: new decimal_1.Dec(21),
                expQuo: new decimal_1.Dec("428571428571428571", 18),
                expQuoRoundUp: new decimal_1.Dec("428571428571428572", 18),
                expQuoTruncate: new decimal_1.Dec("428571428571428571", 18),
                expAdd: new decimal_1.Dec(10),
                expSub: new decimal_1.Dec(-4),
            },
            {
                d1: new decimal_1.Dec(100),
                d2: new decimal_1.Dec(100),
                expMul: new decimal_1.Dec(10000),
                expMulTruncate: new decimal_1.Dec(10000),
                expQuo: new decimal_1.Dec(1),
                expQuoRoundUp: new decimal_1.Dec(1),
                expQuoTruncate: new decimal_1.Dec(1),
                expAdd: new decimal_1.Dec(200),
                expSub: new decimal_1.Dec(0),
            },
            {
                d1: new decimal_1.Dec(3333, 4),
                d2: new decimal_1.Dec(333, 4),
                expMul: new decimal_1.Dec(1109889, 8),
                expMulTruncate: new decimal_1.Dec(1109889, 8),
                expQuo: new decimal_1.Dec("10.009009009009009009"),
                expQuoRoundUp: new decimal_1.Dec("10.009009009009009010"),
                expQuoTruncate: new decimal_1.Dec("10.009009009009009009"),
                expAdd: new decimal_1.Dec(3666, 4),
                expSub: new decimal_1.Dec(3, 1),
            },
        ];
        for (const test of tests) {
            const resAdd = test.d1.add(test.d2);
            const resSub = test.d1.sub(test.d2);
            const resMul = test.d1.mul(test.d2);
            const resMulTruncate = test.d1.mulTruncate(test.d2);
            assert_1.default.strictEqual(resAdd.toString(), test.expAdd.toString(), "invalid result of add");
            assert_1.default.strictEqual(resSub.toString(), test.expSub.toString(), "invalid result of sub");
            assert_1.default.strictEqual(resMul.toString(), test.expMul.toString(), "invalid result of mul");
            assert_1.default.strictEqual(resMulTruncate.toString(), test.expMulTruncate.toString(), "invalid result of mul");
            if (test.d2.isZero()) {
                assert_1.default.throws(() => {
                    test.d1.quo(test.d2);
                });
            }
            else {
                const resQuo = test.d1.quo(test.d2);
                const resQuoRoundUp = test.d1.quoRoundUp(test.d2);
                const resQuoTruncate = test.d1.quoTruncate(test.d2);
                assert_1.default.strictEqual(resQuo.toString(), test.expQuo.toString(), "invalid result of quo");
                assert_1.default.strictEqual(resQuoRoundUp.toString(), test.expQuoRoundUp.toString(), "invalid result of quo round up");
                assert_1.default.strictEqual(resQuoTruncate.toString(), test.expQuoTruncate.toString(), "invalid result of quo truncate");
            }
        }
    });
    it("dec should be round up properly", () => {
        const tests = [
            {
                d1: new decimal_1.Dec("0.25"),
                exp: new int_1.Int("0"),
            },
            {
                d1: new decimal_1.Dec("0"),
                exp: new int_1.Int("0"),
            },
            {
                d1: new decimal_1.Dec("1"),
                exp: new int_1.Int("1"),
            },
            {
                d1: new decimal_1.Dec("0.75"),
                exp: new int_1.Int("1"),
            },
            {
                d1: new decimal_1.Dec("0.5"),
                exp: new int_1.Int("0"),
            },
            {
                d1: new decimal_1.Dec("7.5"),
                exp: new int_1.Int("8"),
            },
            {
                d1: new decimal_1.Dec("0.545"),
                exp: new int_1.Int("1"),
            },
            {
                d1: new decimal_1.Dec("1.545"),
                exp: new int_1.Int("2"),
            },
        ];
        for (const test of tests) {
            const resNeg = test.d1.neg().round();
            assert_1.default.strictEqual(resNeg.toString(), test.exp.neg().toString());
            const resPos = test.d1.round();
            assert_1.default.strictEqual(resPos.toString(), test.exp.toString());
        }
    });
    it("dec should be round up truncated", () => {
        const tests = [
            {
                d1: new decimal_1.Dec("0"),
                exp: new int_1.Int("0"),
            },
            {
                d1: new decimal_1.Dec("0.25"),
                exp: new int_1.Int("0"),
            },
            {
                d1: new decimal_1.Dec("0.75"),
                exp: new int_1.Int("0"),
            },
            {
                d1: new decimal_1.Dec("1"),
                exp: new int_1.Int("1"),
            },
            {
                d1: new decimal_1.Dec("7.5"),
                exp: new int_1.Int("7"),
            },
            {
                d1: new decimal_1.Dec("7.6"),
                exp: new int_1.Int("7"),
            },
            {
                d1: new decimal_1.Dec("8.5"),
                exp: new int_1.Int("8"),
            },
            {
                d1: new decimal_1.Dec("100.000000001"),
                exp: new int_1.Int("100"),
            },
        ];
        for (const test of tests) {
            const resNeg = test.d1.neg().truncate();
            assert_1.default.strictEqual(resNeg.toString(), test.exp.neg().toString());
            const resPos = test.d1.truncate();
            assert_1.default.strictEqual(resPos.toString(), test.exp.toString());
        }
    });
    it("dec should be parsed to string properly", () => {
        const tests = [
            {
                d1: new decimal_1.Dec("0"),
                precision: 0,
                exp: "0",
            },
            {
                d1: new decimal_1.Dec("1.25"),
                precision: 0,
                exp: "1",
            },
            {
                d1: new decimal_1.Dec("0.75"),
                precision: 1,
                exp: "0.7",
            },
            {
                d1: new decimal_1.Dec("1"),
                precision: 5,
                exp: "1.00000",
            },
            {
                d1: new decimal_1.Dec("7.5"),
                precision: 3,
                exp: "7.500",
            },
            {
                d1: new decimal_1.Dec("100.000000001"),
                precision: 0,
                exp: "100",
            },
            {
                d1: new decimal_1.Dec("-0.25"),
                precision: 0,
                exp: "0",
            },
            {
                d1: new decimal_1.Dec("-1.25"),
                precision: 0,
                exp: "-1",
            },
            {
                d1: new decimal_1.Dec("-0.75"),
                precision: 1,
                exp: "-0.7",
            },
            {
                d1: new decimal_1.Dec("-1"),
                precision: 5,
                exp: "-1.00000",
            },
            {
                d1: new decimal_1.Dec("-7.5"),
                precision: 3,
                exp: "-7.500",
            },
            {
                d1: new decimal_1.Dec("-100.000000001"),
                precision: 0,
                exp: "-100",
            },
        ];
        for (const test of tests) {
            const res = test.d1.toString(test.precision);
            assert_1.default.strictEqual(res, test.exp);
        }
    });
});
//# sourceMappingURL=decimal.spec.js.map