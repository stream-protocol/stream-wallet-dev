"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignDocWrapper = void 0;
const decoder_1 = require("../decoder");
const buffer_1 = require("buffer/");
class SignDocWrapper {
    constructor(mode, message) {
        this.mode = mode;
        this.message = message;
    }
    static fromAminoSignDoc(signDoc) {
        const wrapper = new SignDocWrapper("amino", new Uint8Array(0));
        wrapper._aminoSignDoc = signDoc;
        return wrapper;
    }
    static fromDirectSignDoc(signDoc) {
        const wrapper = new SignDocWrapper("direct", new Uint8Array(0));
        wrapper._protoSignDoc = new decoder_1.ProtoSignDocDecoder(signDoc);
        return wrapper;
    }
    clone() {
        return new SignDocWrapper(this.mode, this.message);
    }
    get protoSignDoc() {
        if (!this._protoSignDoc) {
            this._protoSignDoc = decoder_1.ProtoSignDocDecoder.decode(this.message);
        }
        return this._protoSignDoc;
    }
    get aminoSignDoc() {
        if (!this._aminoSignDoc) {
            this._aminoSignDoc = JSON.parse(buffer_1.Buffer.from(this.message).toString());
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._aminoSignDoc;
    }
    get chainId() {
        if (this.mode === "direct") {
            return this.protoSignDoc.chainId;
        }
        return this.aminoSignDoc.chain_id;
    }
    get memo() {
        if (this.mode === "direct") {
            return this.protoSignDoc.txBody.memo;
        }
        return this.aminoSignDoc.memo;
    }
    get fees() {
        var _a, _b;
        if (this.mode === "direct") {
            const fees = [];
            for (const coinObj of (_b = (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.amount) !== null && _b !== void 0 ? _b : []) {
                if (coinObj.denom == null || coinObj.amount == null) {
                    throw new Error("Invalid fee");
                }
                fees.push({
                    denom: coinObj.denom,
                    amount: coinObj.amount,
                });
            }
            return fees;
        }
        return this.aminoSignDoc.fee.amount;
    }
    get gas() {
        var _a, _b, _c;
        if (this.mode === "direct") {
            return (_c = (_b = (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.gasLimit) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;
        }
        return parseInt(this.aminoSignDoc.fee.gas);
    }
}
exports.SignDocWrapper = SignDocWrapper;
//# sourceMappingURL=index.js.map